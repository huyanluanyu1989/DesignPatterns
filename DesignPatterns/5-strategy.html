<!DOCTYPE html>
<html>
<head>
	<title>strategy</title>
</head>
<body>
<script type="text/javascript">
	/**
	 * 使用策略模式计算奖金
	 * S 4个月奖金
	 * A 3个月奖金
	 * B 2个月奖金
	 */
	
	//1、最原始实现方式
	//缺点：
	//（1）calculate函数比较庞大，包含了很多判断语句，这些语句必须包含所有的逻辑分支
	//（2）函数缺乏弹性，如果增加了新的绩效等级，或者想把绩效等级的奖金系数修改一下，我们必须深入calculate函数内部实
	//现违反了开放-封闭原则
	//算法的复用性差，如果在程序的其它地方用到这些算法，我们只能复制粘帖
	// var calculateBonus = function(performanceLevel, salary){
	// 	switch(performanceLevel){
	// 		case 'S':
	// 		return salary*4
	// 		break
	// 		case 'A':
	// 		return salary*3
	// 		break
	// 		case 'B':
	// 		return salary*2
	// 		break
	// 		default:
	// 		return salary
	// 		break
	// 	}
	// }
	// console.log(calculateBonus('A',10000))

	//2、使用组合函数重构代码
	//优点：（1）把各种算法封装到一个个的小函数里，可以一目了然的知道对应的哪种算法
	//（2）复用性强
	//缺点：calculateBouns函数会越来越庞大，在系统变化的时候缺乏弹性
	// var performanceS = function(salary){
	// 	return salary*4
	// }
	// var performanceA = function(salary){
	// 	return salary*3
	// }
	// var performanceB = function(salary){
	// 	return salary*2
	// }

	// var calculateBonus = function(performanceLevel, salary){
	// 	switch(performanceLevel){
	// 		case 'S':
	// 		return performanceS(salary)
	// 		break
	// 		case 'A':
	// 		return performanceA(salary)
	// 		break
	// 		case 'B':
	// 		return performanceB(salary)
	// 		break
	// 	}
	// }
	// console.log(calculateBonus('B',10000))
	

	//3、使用策略模式重构代码，将不变的部分和变化的部分隔离开来，策略模式的目的就是将算法的使用和算法的实现分离开来。
	//一个基于策略模式的程序至少由两部分组成。
	//第一部分是策略类，策略类封装了具体的算法，并负责具体的计算过程。
	//第二部分是环境类Context，Context接收用户的请求，随后把请求委托给某一个策略类。
	
	
	//把每种绩效的计算规则都封装在对应的策略类里面
	var performanceS = function(){}
	performanceS.prototype.calculate = function(salary){
		return salary*4
	}
	var performanceA = function(){}
	performanceA.prototype.calculate = function(salary){
		return salary*3
	}
	var performanceB = function(){}
	performanceB.prototype.calculate = function(salary){
		return salary*2
	}

	//定义奖金类Bonus
	var Bonus = function(){
		this.salary = null
		this.strategy = null
	}

	//设置原始工资
	Bonus.prototype.setSalary = function(salary){
		this.salary = salary
	}

	//设置绩效等级对应的策略对象
	Bonus.prototype.setStrategy = function(strategy){
		this.strategy = strategy
	}

	//取得奖金数额
	Bonus.prototype.getBonus = function(){
		//把计算奖金的操作委托给对应的策略对象
		return this.strategy.calculate(this.salary)
	}
</script>
</body>
</html>