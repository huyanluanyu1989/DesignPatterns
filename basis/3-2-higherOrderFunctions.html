<!DOCTYPE html>
<html>
<head>
	<title>higherOrderFunctions</title>
</head>
<body>
<script type="text/javascript">
	//判断数据的类型
	// var isType = function( type ){
	// 	return function( obj ){
	// 		return Object.prototype.toString.call( obj ) === '[object '+ type +']';
	// 	}
	// };
	// var isString = isType( 'String' );
	// var isArray = isType( 'Array' );
	// var isNumber = isType( 'Number' );
	// console.log( isArray( [ 1, 2, 3 ] ) ); // 输出：true

	//判断数据的类型
	// var Type = {};
	// for(var i=0,type;type=['String','Array','Number'][i++];){
	// 	(function(type){
	// 		Type['is'+type] = function(obj){
	// 			return Object.prototype.toString.call(obj) === '[object '+type+']';
	// 		}
	// 	})(type)
	// }
	// console.log(Type.isArray([ 1, 2, 3 ] ));
	// console.log(Type.isString('str'));


	//2.  getSingle单例模式
	// var getSingle = function(fn){
	// 	var ret;
	// 	return function(){
	// 		return ret || (ret = fn.apply(this, arguments));
	// 	}
	// }

	// var getScript = getSingle(function(){
	// 	return document.createElement('script');
	// })
	// var script1 = getScript();
	// console.log(script1);

	//通过扩展 Function.prototype来实现面向切面
	Function.prototype.before = function(beforefn){
		var _self = this; //保存原函数的引用
		//返回包含原函数和新函数的“代理”函数
		return function(){
			beforefn.apply(this, arguments); //执行新函数，修正this
			return _self.apply(this,arguments); //执行原函数
		}
	}

	Function.prototype.after = function(afterfn){
		var _self = this;
		return function(){
			var ref = _self.apply(this, arguments);
			afterfn.apply(this.arguments);
			return ref;
		}
	}

	var func = function(){
		console.log(2);
	}

	func = func.after(function(){
		console.log(1);
	}).before(function(){
		console.log(3);
	})
	func();
</script>
</body>
</html>